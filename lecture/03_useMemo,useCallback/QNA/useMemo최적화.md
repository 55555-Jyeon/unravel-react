## useMemo는 최적화에 도움이 될까?

useMemo의 역할은 계산 성능이 비싼 결과에 대해 값을 캐싱(memoization)에 매번 불필요한 계산 없이 값 자체를 반환하는 방법을 의미한다.

우리가 useState나 useRef, useMemo, useCallback에서 얘기가 나오는 이 memoizedState가 memoization해서 나온 값을 저장한다 라는 의미라고도 할 수 있다.

<br />

### Memoization

사실 이 [Memoization](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98)은 프론트 에서만 사용되는 개념은 아니다. 모든 프로그램에서 사용되는 개념으로, 컴퓨터 프로그램에서 동일한 계산을 반복해야 할 때 이전에 계산한 값을 메모리에 별도로 저장해 계속해서 해당 계산을 수행하지 않고 값만 반환하는 것으로 프로그램 실행 속도를 빠르게 하는 기술이다.

이 기술이 동적 계획법(DP 알고리즘)의 핵심이 된다.

**사용예시**

- useMemo
- DP - 피보나치 수열에 응용됨
- DB query cache (이건 예시보다는 query의 결과 값을 캐싱 한다에 가까움)

<br />

### Memoization이 꼭 좋은 것 일까?

가장 중요하게 알고 있어야 하는 점은 최적화라는 것은 **공짜가 아닌 것** 이다.

Memoization에 필요한 비용 중 하나는 메모리다.
기존에 함수를 이용해서 반환 받은 결과 값을 그대로 이용하게 될 때는 저장할 메모리는 따로 없이 임시로 만들어진 변수를 활용하게 된다.

```js
function getLargeTotal(array: number[]) {
  return array.reduce((acc, cur) => {
    return acc + cur;
  }, 0);
}

// 변수로 할당한 것은 아니기에 결과만 나오지 별도의 메모리를 활용하는 것은
// 아니라고 볼 수 있다. 직접 출력하는 경우는 그냥 단순하게 결과만 띄워주기 때문이다.
console.log(getLargeTotal([1, 2, 3, 4, 5]));

const a = getLargeTotal([1, 2, 3, 4, 5]); // 이건 메모리에 할당 된다.
const b = useMemo(() => getLargeTotal([1, 2, 3, 4, 5]), []); // 이것도 메모리에 할당 된다.
```

위의 코드를 보면 a로 선언한 것과 b로 선언한 것 둘 다 메모리를 사용하게 된다. 그렇다면 왜 굳이 a처럼 바로 변수로 선언해 사용하지 않고 useMemo로 묶어서 사용하는 것 일까?

리액트의 경우 컴포넌트가 렌더링, 재렌더링 될 때 함수의 처음부터 다시 선언되는 특징을 가지고 있다. useState, useRef 의 상태 관리 및 변수 관리 hook은 기존에 fiber노드에 값 들을 저장하고 있고, 재 선언시 이전 값을 불러오는 특징을 가지고 있기에 문제가 없다.

a 변수의 케이스는 매 리렌더링 마다 해당 값을 다시 계산해 선언해줘야 하는 특징을 가지고있지만, useMemo를 이용해 선언하는 경우는 리렌더링이 되더라도 2번째 array의 값이 변경 되었는가에 따라 재 계산을 할 지 기존의 값을 사용할 것 인지 결정해주게 된다.

이 말은 즉 변경 된지 아닌지를 비교하기 위해 필요한 값 또한 저장해야 할 필요가 있다는 것이다.

예를 들어 0부터 10만 까지 있는 배열 `abc` 의 총 합을 useMemo로 감싸게 된다면, 연산 비용은 줄 수 있지만, 캐싱 처리 이후 배열 값이 변경되었는지 확인하기 위해 `abc` 값 또한 캐싱 하고, 같은 지 다른지를 검증하는 로직 또한 돌아가야 한다.

즉 비교할 값이 많아질 수록, 캐싱(Memoization)이 속도는 빨라지더라도 메모리를 잡아먹어 OutOfMemory 이슈를 발생 시킬 수 있다는 것 이다.

<br />

또 한 가지 문제는 비교 연산을 위해 들어간 이 값들이 참조 타입인 경우 내부 값이 바뀌게 된다 한들 메모리 주소가 바뀌지 않는 경우도 존재한다. 이런 경우도 문제가 발생할 수 있다.

```js
const dependencyArrayValue = [1, 2, 3, 4, 5];

function App() {
  const a = useMemo(
    () => dependencyArrayValue.reduce((acc, cur) => acc + cur),
    [dependencyArrayValue]
  );

  useEffect(() => {
    dependencyArrayValue.push(dependencyArrayValue.length + 1);
  }, []);

  // mount 시 6이라는 값이 들어가더라도 a라는 값 자체는 변하지 않는다.
  return <div>{a}</div>;
}
```

<br>
<br>

### 비싼 연산인지 확인하는 방법

<img src="https://github.com/user-attachments/assets/7d0dbc0f-adf6-4b90-8ea4-b0e6861d28c7" />

보통 프로그램은 1초에 3억 번 ~ 5억 번의 연산을 처리한다고 한다.

프로그램 입장에서는 사실 100번이든, 1000번이든 계산하더라도 그 시간이 부담이 되지 않는다고도 할 수 있다.

다만 우리가 사용하는 것은 리액트이다. 리액트에서는 우리가 보이지 않는 것 뿐이지 내부에서도 많은 연산이 돌아간다. 그렇기에 리액트 문서에서는 어느 정도가 무거운 연산인지 정해준다.

약 1ms (0.001초)면 무거운 연산이다 라고 인지하면 된다고 말한다.

1초에 3~5억 번을 연산하는 입장에서 0.001초라고 말한다면 0.001초에 30 ~ 50만 번을 연산하는 경우가 무겁다 라고 할 수 있다는 것이다.

우리에게는 이 정도 연산이 있는 경우는 없고, 최근 컴퓨터, 핸드폰의 성능 또한 좋다는 점을 생각해보면 굳이 캐싱 처리를 한다고 엄청난 렌더링 속도가 증가 된다고 보기도 어렵다 할 수 있다.

<br />
<br />

### 최적화 챙기는 방법

사실 최적화라는 것은 기본적인 것만 잘 지켜줘도 잘 해결된다.

1. 전역 및 최상위 context 사용 **조심**하기 (ex. redux, zustand 등의 전역 상태 관리 라이브러리)
2. eventListener 관련 컴포넌트 unmount시 해제 잘 하기
3. 외부 JS 라이브러리에서 사용되는 전역 변수 관리 잘 확인하기
4. memoization은 실제로 렌더링 성능에 영향이 있을 때 사용하기

<br />
<br />

## 참고 자료

https://ko.react.dev/reference/react/useMemo
