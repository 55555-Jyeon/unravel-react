## useState 톺아보기

#### useState 같은 상태 관리 hook의 동작 원리

- useState에 closure개념이 사용되었다는 이유가 뭘까
- useState에서 객체나 배열을 사용하기 까다로운 이유가 뭘까
- useState를 선언할 때 반드시 const로 하는 이유가 뭘까
- useState는 비동기인가 동기인가 (마지박 수업으로 보류)

<br />
<br />

##### 용어 정리

> 📖 linked-list <br />
> 데이터 요소들을 순차적으로 연결해 저장하는 방식의 데이터 자료 구조 <br />
> 각 요소는 데이터와 다음 요소를 가리키는 참조(링크)로 구성

<br />
<br />

##### 전반적인 플로우

<p align="center">
<img width="90%" src="https://github.com/user-attachments/assets/8cf66f85-923b-4948-aefe-190f09f2b8f3" alt="useState code flow" />
</p>

<br />
<br />

### 챌린지 내용 정리

#### 1️⃣ useState의 구조 파악하기

소스 코드를 확인하며 useState의 구조를 파악해보자

###### ReactSharedInternals.js

소스 코드를 살펴 보면 의존성 주입을 통해 ReactSharedInternals 값을 변경시켜 React에서 사용하는 Hook 객체 정보를 넣어주는 것을 확인할 수 있습니다.

- `📂 packages/react/src/ReactHooks.js`
- `🔗 https://github.com/facebook/react/blob/main/packages/react/src/ReactHooks.js`

```js
import ReactSharedInternals from "shared/ReactSharedInternals";

export function useState<S>(
  initialState: (() => S) | S
): [S, Dispatch<BasicStateAction<S>>] {
  // 아래의 함수 resolveDispatcher에서 반환한 객체를 사용
  const dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}

function resolveDispatcher() {
  // ReactSharedInternals.H 라는 값을 반환
  const dispatcher = ReactSharedInternals.H;
  if (__DEV__) {
    if (dispatcher === null) {
      console.error(
        "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for" +
          " one of the following reasons:\n" +
          "1. You might have mismatching versions of React and the renderer (such as React DOM)\n" +
          "2. You might be breaking the Rules of Hooks\n" +
          "3. You might have more than one copy of React in the same app\n" +
          "See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
      );
    }
  }

  return ((dispatcher: any): Dispatcher);
}
```

- `📂 packages/shared/ReactSharedInternals.js`
- `🔗 https://github.com/facebook/react/blob/main/packages/shared/ReactSharedInternals.js`

```js
import * as React from "react";

// React에서 import 받은 __CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE라는 값을 활용
const ReactSharedInternals =
  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;

export default ReactSharedInternals;
```

- `📂 packages/react/src/ReactSharedInternalsClient.js`
- `🔗 https://github.com/facebook/react/blob/main/packages/react/src/ReactSharedInternalsClient.js`

```js
export type SharedStateClient = {
  H: null | Dispatcher, // ✅ Hook 관련 정보를 주입할 곳, null이거나 Dispatcher 타입
  A: null | AsyncDispatcher,
  T: null | BatchConfigTransition
  S: null | ((BatchConfigTransition, mixed) => void)

const ReactSharedInternals: SharedStateClient = ({
  H: null,
  A: null,
  T: null,
  S: null,
}: any);

export default ReactSharedInternals;

// ... other codes ...
}
```

<br />
<br />

#### 값 할당하기

```js
hook.memoizedState = hook.baseState = initialState;
const queue: UpdateQueue<S, BasicStateAction<S>> = {
  pending: null,
  lanes: NoLanes,
  dispatch: null,
  lastRenderedReducer: basicStateReducer,
  lastRenderedState: (initialState: any),
};
hook.queue = queue;
return hook;
```

이후 다음과 같은 작업을 수행 :

1. `hook.memoizedState` 와 `hook.baseState` 에 `initialState` 값을 집어넣어 준다. (baseState는 이따 나오게 된다)
2. hook 객체의 queue 정보에 알수 없는 정보를 넣어준다.
   1. lanes: NoLanes (이후 fiber에서 더 자세하게 다룰 예정)
   2. lastRenderedReducer
   3. lastRenderedState: initialState 즉 초기 값을 넣어준다.

이후 모든 정보들을 취합해 하나의 hook 객체로 만든 이후 반환해준다.

<br />
<br />

#### 2️⃣ function renderWithHooks

renderWithHooks 라는 함수는 beginWorks라는 함수를 통해 리렌더링에 필요한 Fiber 객체들을 이용해 컴포넌트간의 차이를 비교하는 재조정(Reconciler)을 통해 Hook 정보를 넣어주게 됩니다.

```js
export function renderWithHooks<Props, SecondArg>(
  current: Fiber | null, // 업데이트 전 (현재 렌더링 중인 화면의 hook 정보들)
  workInProgress: Fiber, // 새로 업데이트하기 위해 필요한 hook 정보들
  Component: (p: Props, arg: SecondArg) => any,
  props: Props,
  secondArg: SecondArg,
  nextRenderLanes: Lanes
): any {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress;

  if (__DEV__) {
    hookTypesDev =
      current !== null
        ? ((current._debugHookTypes: any): Array<HookType>)
        : null;
    hookTypesUpdateIndexDev = -1;
    // Used for hot reloading:
    ignorePreviousDependencies =
      current !== null && current.type !== workInProgress.type;

    warnIfAsyncClientComponent(Component);
  }

  // 매개변수 객체를 직접 수정하는 케이스
  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = NoLanes;

  if (__DEV__) {
    // 개발 로직이기에 삭제
  } else {
    ReactSharedInternals.H =
      current === null || current.memoizedState === null
        ? HooksDispatcherOnMount
        : HooksDispatcherOnUpdate;
  }

  // 개발 환경에서 두번 리렌더링이 필요한가?
  const shouldDoubleRenderDEV =
    __DEV__ &&
    debugRenderPhaseSideEffectsForStrictMode &&
    (workInProgress.mode & StrictLegacyMode) !== NoMode;

  shouldDoubleInvokeUserFnsInHooksDEV = shouldDoubleRenderDEV;
  let children = __DEV__
    ? callComponentInDEV(Component, props, secondArg)
    : Component(props, secondArg);
  shouldDoubleInvokeUserFnsInHooksDEV = false;

  /**
	 렌더 패스 중에만 업데이트가 예약된 경우 시도할 때 마다 재설정되는
	값으로 didScheduleRenderPhaseUpdate 나 numberOfReRenders을 이용해
	통합할 수 있는 방법이 있어보인다. 라는 것을 미루어볼 때 굳이 신경쓸 필요는 없는
	친구로 보인다.
  */
  if (didScheduleRenderPhaseUpdateDuringThisPass) {
    children = renderWithHooksAgain(
      workInProgress,
      Component,
      props,
      secondArg
    );
  }

  if (shouldDoubleRenderDEV) {
    setIsStrictModeForDevtools(true);
    try {
      children = renderWithHooksAgain(
        workInProgress,
        Component,
        props,
        secondArg
      );
    } finally {
      setIsStrictModeForDevtools(false);
    }
  }

  // 모든 hook 계산 로직들을 수행한 이후 기존에 사용하던 객체들을 비우는 작업을 수행
  finishRenderingHooks(current, workInProgress, Component);

  return children;
}
```

###### currentRenderingFiber

currentRenderingFiber는 Fiber 타입의 객체로 변경될 fiber 노드 정보를 별도의 변수에 저장해서 활용합니다.

```js
currentlyRenderingFiber = workInProgress;
```

```js
export type Fiber = {
	.
	.
	.
	memoizedState: any; // hook을 위한 fiber 노드에서 저장된, state 관련 정보 저장 값
	.
	.
}
```

위에서 보여지는 Fiber 객체는 현재 Hook에서 비교하고 있는 Fiber 노드를 저장하는 위치로,
현재 진행 중인 useState같은 상태 관리 hook 관련 정보를 전부 저장하는 공간입니다.

임시 공간이기에 렌더링이 완료되면 비워진다.

```js
// 매개변수 객체를 직접 수정하는 케이스
workInProgress.memoizedState = null;
workInProgress.updateQueue = null;
workInProgress.lanes = NoLanes;
```

일반적으로 함수에서 받아온 매개변수는 직접 수정이 불가능합니다. <br />
하지만 해당 함수에서는 직접 수정하고 있는데 이 이유는 **Value Type and Reference Type**과 연관되어 있습니다.

<br />

###### 🌟 Value Type and Reference Type

**Value Type and Reference Type**은 변수 할당 방법과 관련이 있습니다. <br />
변수 값이 들어가게 된다면, 그 변수를 저장하기 위해 메모리 공간이 할당되고 그 메모리 공간의 주소 또한 반환되게 되는 것을 말합니다.

1.  Call by Value (Value Type)

Call by Value는 원시 타입(primitive type)으로 메모리 공간이 할당되더라도 실제로 반환하는 값은 값 자체를 반환하게 됩니다. <br />
C 계열의 언어(C, C++ 등)에서는 해당 값의 메모리 주소를 가져오는 pointer 또한 사용이 가능하지만 기본적으로는 값 자체를 가져오게 됩니다.

2. Call by Reference (Reference Type)

Call by Reference는 참조 타입(reference type)으로 실제 데이터가 보관되는 메모리 주소에 대한 참조 값을 저장됩니다. <br />
예를 들어 `{ a: "Test" }` 라는 객체를 A 라는 변수에 저장하게 된다면, 남는 메모리 공간에 값이 할당되게 되고 A라는 값에는 메모리 주소가 반환됩니다.

```c++
#include <iostream>

// 실제로 메모리 주소를 활용하는 언어인 C++ 예시 코드
// 우리가 현재 사용하는 JS와 Java에는 해당되지 않으니 그냥 이렇구나 정도로 보길 권장
int main()
{
    int a = 10;
     // JS에서는 console와 같은 기능을 담당
     // 앞에 &를 붙임으로써 메모리 주소를 가져온다고 생각하면 편함
    std::cout << &a << std::endl; // 0xdfbffffdcc -> 16진수 메모리 주소 반환

    return 0;
}
```

물론 실제로 우리가 그 변수를 활용할 때는 값 자체가 반환되게 되는데, 실제로는 메모리 주소가 저장되어 있어 변수를 활용할 때는 그 주소에서 값을 꺼내와서 반환하게 되는 구조입니다.

<br />

###### 예제

```js
const a = { a: "test" };
const b = a;
const c = { a: "test" };

1. console.log(a === b); // ?
2. console.log(a === c); // ?

a.a = "b";
3. console.log(a.a); // ?
4. console.log(b.a); // ?
```

<br />
<br />

#### isUpdate

실제로 리액트 내에 있는 함수는 아닙니다. <br />
실제 그림에서 그린 핵심 로직은 아래 내용으로 아래 코드만 인지하고 있으면 됩니다.

```js
ReactSharedInternals.H =
  // (current === null || current.memoizedState === null)의 조건은 mount
  current === null || current.memoizedState === null
    ? HooksDispatcherOnMount
    : HooksDispatcherOnUpdate;
```

- `📂 package/react-reconciler/src/ReactFiberHooks.js`

```js
const HooksDispatcherOnMount: Dispatcher = {
  readContext,
  use,
  useCallback: mountCallback,
  useContext: readContext,
  useEffect: mountEffect,
  useImperativeHandle: mountImperativeHandle,
  useLayoutEffect: mountLayoutEffect,
  useInsertionEffect: mountInsertionEffect,
  useMemo: mountMemo,
  useReducer: mountReducer,
  useRef: mountRef,
  useState: mountState, // ✅
  useDebugValue: mountDebugValue,
  useDeferredValue: mountDeferredValue,
  useTransition: mountTransition,
  useSyncExternalStore: mountSyncExternalStore,
  useId: mountId,
};

const HooksDispatcherOnUpdate: Dispatcher = {
  readContext,
  use,
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useInsertionEffect: updateInsertionEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: updateReducer,
  useRef: updateRef,
  useState: updateState, // ✅
  useDebugValue: updateDebugValue,
  useDeferredValue: updateDeferredValue,
  useTransition: updateTransition,
  useSyncExternalStore: updateSyncExternalStore,
  useId: updateId,
};
```

<br />
<br />

#### 4️⃣ currentHook, workInProgressHook

```js
export type Hook = {
  memoizedState: any, // ✅ 실제 렌더링 시 노출시켜줄 state 값
  // 내부에서 변경된 값 자체를 당장 저장하는 state 값
  // 실제 setState((prev) => {}); 사용시 prev에서 사용하는 값
  baseState: any, // 실제 리렌더링 되기 전까지는 baseState에 우선 값을 적용하고 이후 memoizedState에 값을 적용
  baseQueue: Update<any, any> | null,
  queue: any,
  next: Hook | null, // 다음 hook 객체 정보를 저장하기 위해 Linked List 구조로 사용
};
```

> 🔖 memoizedState <br />
> 실제 렌더링 시 노출시켜줄 state 값 <br />
> 내부에서 변경된 값 자체를 당장 저장하는 state 값

```js
// memoizedState & baseState

const [state, setState] = useState(0);

const plusOne = () => {
  setState((prev) => prev + 1);
};
```

<br />

> 🔖 CurrentHook <br />
> 이름 그대로 각각 업데이트 전의 Hook 정보 <br />
> 즉 리렌더링 이전의 Hook 객체

<br />

> 🔖 workInProgressHook <br />
> 리렌더링을 위해 새로 할당된 Fiber 노드 기반으로 만들어지는 Hook 객체 <br />
> 임시 공간이기에 렌더링이 완료되면 비워짐

<br />
<br />

#### 5️⃣ mountState

##### MountState 분석

```js
function mountState<S>(
  initialState: (() => S) | S
): [S, Dispatch<BasicStateAction<S>>] {
  const hook = mountStateImpl(initialState);
  const queue = hook.queue;
  const dispatch: Dispatch<BasicStateAction<S>> = (dispatchSetState.bind(
    null,
    currentlyRenderingFiber,
    queue
  ): any);
  queue.dispatch = dispatch;
  return [hook.memoizedState, dispatch];
}
```

##### MountStateImpl 분석

우리가 사용할 정보들을 대부분 가져오는 mountStateImpl이라는 함수에서는 hook이라는 객체를 반환해주기 위한 작업을 수행합니다.

```js
function mountStateImpl<S>(initialState: (() => S) | S): Hook {
  const hook = mountWorkInProgressHook(); // ✅
  // useState의 lazyInitialize에 대한 로직 - todo: 예시 코드 만들어보기
  if (typeof initialState === "function") {
    const initialStateInitializer = initialState;
    initialState = initialStateInitializer(); // ✅
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(true);
      initialStateInitializer(); // "strict mode"에서 두 번 호출되는 이유
      setIsStrictModeForDevtools(false);
    }
  }
  hook.memoizedState = hook.baseState = initialState; // ✅ mount 시점에 단 한 번만 호출해 처리할 목적
  const queue: UpdateQueue<S, BasicStateAction<S>> = {
    pending: null,
    lanes: NoLanes,
    dispatch: null,
    // baseStateReducer라는 함수를 그대로 저장함. 추후 parameter를 넣어서 활용
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: (initialState: any),
  };
  hook.queue = queue;
  return hook;
}
```

##### mountWorkInProgressHook

workInProgressHook 정보가 있냐 없냐에 따라 아래 작업을 수행합니다 :

- 값이 없다면 `currentRenderingFiber`와 `workInProgressHook` 객체 안에 새로 만든 Hook 객체 정보를 주입
- 그것이 아니라면 `workInProgressHook`와 `workInProgressHook.next`에 hook 객체를 넣어줌으로써 **Linked List**를 구현

그 이후 workInProgressHook를 반환해줍니다.

```js
function mountWorkInProgressHook(): Hook {
  const hook: Hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook === null) {
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook; // This is the first hook in the list
  } else {
    workInProgressHook = workInProgressHook.next = hook; // Append to the end of the list
  }

  return workInProgressHook;
}
```

###### 게으른 초기화

아래 로직을 통해 게으른 초기화를 시킵니다.

```js
if (typeof initialState === "function") {
  const initialStateInitializer = initialState;
  initialState = initialStateInitializer();
  if (shouldDoubleInvokeUserFnsInHooksDEV) {
    setIsStrictModeForDevtools(true);
    initialStateInitializer();
    setIsStrictModeForDevtools(false);
  }
}
```

<br />
<br />

#### 6️⃣ basicStateReducer

setState를 만들기 위해 필요한 함수로, action에 들어가는 값이 함수가 아니라면 action 자체를 반환한다.

```js
function basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {
  // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types
  return typeof action === "function" ? action(state) : action;
}
```

action이 함수가 아닌 경우는 setState 기준으로 다음과 같다.

```js
setState(state + 1); // state + 1 이 action으로 들어가는 값 -> 숫자임
```

action이 함수가 되는 경우는 다음과 같다.

```js
setState((prev) => prev + 1); // (prev) => prev + 1이 action으로 들어가는 값 -> 함수임
```

<br />
<br />

#### 7️⃣ dispatchSetState

```js
function dispatchSetState<S, A>(
  fiber: Fiber,
  queue: UpdateQueue<S, A>,
  action: A
): void {
  if (__DEV__) {
    if (typeof arguments[3] === "function") {
      console.error(
        "State updates from the useState() and useReducer() Hooks don't support the " +
          "second callback argument. To execute a side effect after " +
          "rendering, declare it in the component body with useEffect()."
      );
    }
  }

  const lane = requestUpdateLane(fiber);

  const update: Update<S, A> = {
    lane,
    revertLane: NoLane,
    action,
    hasEagerState: false,
    eagerState: null,
    next: (null: any),
  };

  if (isRenderPhaseUpdate(fiber)) {
    enqueueRenderPhaseUpdate(queue, update);
  } else {
    const alternate = fiber.alternate;
    if (
      fiber.lanes === NoLanes &&
      (alternate === null || alternate.lanes === NoLanes)
    ) {
      const lastRenderedReducer = queue.lastRenderedReducer;
      if (lastRenderedReducer !== null) {
        let prevDispatcher = null;
        if (__DEV__) {
          prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        }
        try {
          // lastRenderedState -> initialize된 state
          const currentState: S = (queue.lastRenderedState: any);
          const eagerState = lastRenderedReducer(currentState, action);
          update.hasEagerState = true;
          update.eagerState = eagerState;
          if (is(eagerState, currentState)) {
            enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);
            return;
          }
        } catch (error) {
        } finally {
          if (__DEV__) {
            ReactSharedInternals.H = prevDispatcher;
          }
        }
      }
    }

    const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
    if (root !== null) {
      scheduleUpdateOnFiber(root, fiber, lane);
      entangleTransitionUpdate(root, queue, lane);
    }
  }

  markUpdateInDevTools(fiber, lane, action);
}
```

###### 핵심 로직

```js
const currentState: S = (queue.lastRenderedState: any);
const eagerState = lastRenderedReducer(currentState, action);
update.hasEagerState = true;
update.eagerState = eagerState;
if (is(eagerState, currentState)) {
  enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);
  return;
}
```

setState가 업데이트 되기 위해서 검증하는 작업이 필요한데 해당 로직에서 이전의 state와 새롭게 바뀌는 state를 비교하는 로직이다.

기존 queue 에 들어있는 정보인 lastRerenderedState와 lastRerenderedReducer 두 개는 [이전의 함수](https://www.notion.so/5-mountState-1180d6fc8a7c8076aeaafbedd275a3c6?pvs=21) 에서 값을 할당해줬다.

```js
lastRenderedReducer(currentState, action);
```

위의 lastRerenderedReducer를 통해 setState 작업을 수행한다.

<br />
<br />

#### 8️⃣ updateState

```js
function updateState<S>(
  initialState: (() => S) | S
): [S, Dispatch<BasicStateAction<S>>] {
  return updateReducer(basicStateReducer, initialState);
}

function updateReducer<S, I, A>(
  reducer: (S, A) => S,
  initialArg: I,
  init?: (I) => S
): [S, Dispatch<A>] {
  const hook = updateWorkInProgressHook();
  return updateReducerImpl(hook, ((currentHook: any): Hook), reducer);
}
```

UpdateState는 UpdateReducer 함수를 반환해준다.

UpdateState는 initialState를 Parameter로 넣지만 사용하지는 않고, [6. basicStateReducer](https://www.notion.so/6-basicStateReducer-1180d6fc8a7c808090b6c78f26b2ca7c?pvs=21) 만 사용한다.

###### 핵심 코드

```js
function updateWorkInProgressHook(): Hook {
  let nextCurrentHook: null | Hook;
  if (currentHook === null) {
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  let nextWorkInProgressHook: null | Hook;
  if (workInProgressHook === null) {
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    // There's already a work-in-progress. Reuse it.
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;

    currentHook = nextCurrentHook;
  } else {
    // Clone from the current hook.

    if (nextCurrentHook === null) {
      const currentFiber = currentlyRenderingFiber.alternate;
      if (currentFiber === null) {
        // This is the initial render. This branch is reached when the component
        // suspends, resumes, then renders an additional hook.
        // Should never be reached because we should switch to the mount dispatcher first.
        throw new Error(
          "Update hook called on initial render. This is likely a bug in React. Please file an issue."
        );
      } else {
        // This is an update. We should always have a current hook.
        throw new Error("Rendered more hooks than during the previous render.");
      }
    }

    currentHook = nextCurrentHook;

    const newHook: Hook = {
      memoizedState: currentHook.memoizedState,

      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,

      next: null,
    };

    if (workInProgressHook === null) {
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}
```

<br />
<br />
