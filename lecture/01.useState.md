## useState í†ºì•„ë³´ê¸°

#### useState ê°™ì€ ìƒíƒœ ê´€ë¦¬ hookì˜ ë™ì‘ ì›ë¦¬

- useStateì— closureê°œë…ì´ ì‚¬ìš©ë˜ì—ˆë‹¤ëŠ” ì´ìœ ê°€ ë­˜ê¹Œ
- useStateì—ì„œ ê°ì²´ë‚˜ ë°°ì—´ì„ ì‚¬ìš©í•˜ê¸° ê¹Œë‹¤ë¡œìš´ ì´ìœ ê°€ ë­˜ê¹Œ
- useStateë¥¼ ì„ ì–¸í•  ë•Œ ë°˜ë“œì‹œ constë¡œ í•˜ëŠ” ì´ìœ ê°€ ë­˜ê¹Œ
- useStateëŠ” ë¹„ë™ê¸°ì¸ê°€ ë™ê¸°ì¸ê°€ (ë§ˆì§€ë°• ìˆ˜ì—…ìœ¼ë¡œ ë³´ë¥˜)

<br />
<br />

##### ìš©ì–´ ì •ë¦¬

> ğŸ“– linked-list <br />
> ë°ì´í„° ìš”ì†Œë“¤ì„ ìˆœì°¨ì ìœ¼ë¡œ ì—°ê²°í•´ ì €ì¥í•˜ëŠ” ë°©ì‹ì˜ ë°ì´í„° ìë£Œ êµ¬ì¡° <br />
> ê° ìš”ì†ŒëŠ” ë°ì´í„°ì™€ ë‹¤ìŒ ìš”ì†Œë¥¼ ê°€ë¦¬í‚¤ëŠ” ì°¸ì¡°(ë§í¬)ë¡œ êµ¬ì„±

<br />
<br />

##### ì „ë°˜ì ì¸ í”Œë¡œìš°

<p align="center">
<img width="90%" src="https://github.com/user-attachments/assets/8cf66f85-923b-4948-aefe-190f09f2b8f3" alt="useState code flow" />
</p>

<br />
<br />

### ì±Œë¦°ì§€ ë‚´ìš© ì •ë¦¬

#### 1ï¸âƒ£ useStateì˜ êµ¬ì¡° íŒŒì•…í•˜ê¸°

ì†ŒìŠ¤ ì½”ë“œë¥¼ í™•ì¸í•˜ë©° useStateì˜ êµ¬ì¡°ë¥¼ íŒŒì•…í•´ë³´ì

###### ReactSharedInternals.js

ì†ŒìŠ¤ ì½”ë“œë¥¼ ì‚´í´ ë³´ë©´ ì˜ì¡´ì„± ì£¼ì…ì„ í†µí•´ ReactSharedInternals ê°’ì„ ë³€ê²½ì‹œì¼œ Reactì—ì„œ ì‚¬ìš©í•˜ëŠ” Hook ê°ì²´ ì •ë³´ë¥¼ ë„£ì–´ì£¼ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

- `ğŸ“‚ packages/react/src/ReactHooks.js`
- `ğŸ”— https://github.com/facebook/react/blob/main/packages/react/src/ReactHooks.js`

```js
import ReactSharedInternals from "shared/ReactSharedInternals";

export function useState<S>(
  initialState: (() => S) | S
): [S, Dispatch<BasicStateAction<S>>] {
  // ì•„ë˜ì˜ í•¨ìˆ˜ resolveDispatcherì—ì„œ ë°˜í™˜í•œ ê°ì²´ë¥¼ ì‚¬ìš©
  const dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}

function resolveDispatcher() {
  // ReactSharedInternals.H ë¼ëŠ” ê°’ì„ ë°˜í™˜
  const dispatcher = ReactSharedInternals.H;
  if (__DEV__) {
    if (dispatcher === null) {
      console.error(
        "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for" +
          " one of the following reasons:\n" +
          "1. You might have mismatching versions of React and the renderer (such as React DOM)\n" +
          "2. You might be breaking the Rules of Hooks\n" +
          "3. You might have more than one copy of React in the same app\n" +
          "See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
      );
    }
  }

  return ((dispatcher: any): Dispatcher);
}
```

- `ğŸ“‚ packages/shared/ReactSharedInternals.js`
- `ğŸ”— https://github.com/facebook/react/blob/main/packages/shared/ReactSharedInternals.js`

```js
import * as React from "react";

// Reactì—ì„œ import ë°›ì€ __CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADEë¼ëŠ” ê°’ì„ í™œìš©
const ReactSharedInternals =
  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;

export default ReactSharedInternals;
```

- `ğŸ“‚ packages/react/src/ReactSharedInternalsClient.js`
- `ğŸ”— https://github.com/facebook/react/blob/main/packages/react/src/ReactSharedInternalsClient.js`

```js
export type SharedStateClient = {
  H: null | Dispatcher, // âœ… Hook ê´€ë ¨ ì •ë³´ë¥¼ ì£¼ì…í•  ê³³, nullì´ê±°ë‚˜ Dispatcher íƒ€ì…
  A: null | AsyncDispatcher,
  T: null | BatchConfigTransition
  S: null | ((BatchConfigTransition, mixed) => void)

const ReactSharedInternals: SharedStateClient = ({
  H: null,
  A: null,
  T: null,
  S: null,
}: any);

export default ReactSharedInternals;

// ... other codes ...
}
```

<br />
<br />

#### ê°’ í• ë‹¹í•˜ê¸°

```js
hook.memoizedState = hook.baseState = initialState;
const queue: UpdateQueue<S, BasicStateAction<S>> = {
  pending: null,
  lanes: NoLanes,
  dispatch: null,
  lastRenderedReducer: basicStateReducer,
  lastRenderedState: (initialState: any),
};
hook.queue = queue;
return hook;
```

ì´í›„ ë‹¤ìŒê³¼ ê°™ì€ ì‘ì—…ì„ ìˆ˜í–‰ :

1. `hook.memoizedState` ì™€ `hook.baseState` ì— `initialState` ê°’ì„ ì§‘ì–´ë„£ì–´ ì¤€ë‹¤. (baseStateëŠ” ì´ë”° ë‚˜ì˜¤ê²Œ ëœë‹¤)
2. hook ê°ì²´ì˜ queue ì •ë³´ì— ì•Œìˆ˜ ì—†ëŠ” ì •ë³´ë¥¼ ë„£ì–´ì¤€ë‹¤.
   1. lanes: NoLanes (ì´í›„ fiberì—ì„œ ë” ìì„¸í•˜ê²Œ ë‹¤ë£° ì˜ˆì •)
   2. lastRenderedReducer
   3. lastRenderedState: initialState ì¦‰ ì´ˆê¸° ê°’ì„ ë„£ì–´ì¤€ë‹¤.

ì´í›„ ëª¨ë“  ì •ë³´ë“¤ì„ ì·¨í•©í•´ í•˜ë‚˜ì˜ hook ê°ì²´ë¡œ ë§Œë“  ì´í›„ ë°˜í™˜í•´ì¤€ë‹¤.

<br />
<br />

#### 2ï¸âƒ£ function renderWithHooks

renderWithHooks ë¼ëŠ” í•¨ìˆ˜ëŠ” beginWorksë¼ëŠ” í•¨ìˆ˜ë¥¼ í†µí•´ ë¦¬ë Œë”ë§ì— í•„ìš”í•œ Fiber ê°ì²´ë“¤ì„ ì´ìš©í•´ ì»´í¬ë„ŒíŠ¸ê°„ì˜ ì°¨ì´ë¥¼ ë¹„êµí•˜ëŠ” ì¬ì¡°ì •(Reconciler)ì„ í†µí•´ Hook ì •ë³´ë¥¼ ë„£ì–´ì£¼ê²Œ ë©ë‹ˆë‹¤.

```js
export function renderWithHooks<Props, SecondArg>(
  current: Fiber | null, // ì—…ë°ì´íŠ¸ ì „ (í˜„ì¬ ë Œë”ë§ ì¤‘ì¸ í™”ë©´ì˜ hook ì •ë³´ë“¤)
  workInProgress: Fiber, // ìƒˆë¡œ ì—…ë°ì´íŠ¸í•˜ê¸° ìœ„í•´ í•„ìš”í•œ hook ì •ë³´ë“¤
  Component: (p: Props, arg: SecondArg) => any,
  props: Props,
  secondArg: SecondArg,
  nextRenderLanes: Lanes
): any {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress;

  if (__DEV__) {
    hookTypesDev =
      current !== null
        ? ((current._debugHookTypes: any): Array<HookType>)
        : null;
    hookTypesUpdateIndexDev = -1;
    // Used for hot reloading:
    ignorePreviousDependencies =
      current !== null && current.type !== workInProgress.type;

    warnIfAsyncClientComponent(Component);
  }

  // ë§¤ê°œë³€ìˆ˜ ê°ì²´ë¥¼ ì§ì ‘ ìˆ˜ì •í•˜ëŠ” ì¼€ì´ìŠ¤
  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = NoLanes;

  if (__DEV__) {
    // ê°œë°œ ë¡œì§ì´ê¸°ì— ì‚­ì œ
  } else {
    ReactSharedInternals.H =
      current === null || current.memoizedState === null
        ? HooksDispatcherOnMount
        : HooksDispatcherOnUpdate;
  }

  // ê°œë°œ í™˜ê²½ì—ì„œ ë‘ë²ˆ ë¦¬ë Œë”ë§ì´ í•„ìš”í•œê°€?
  const shouldDoubleRenderDEV =
    __DEV__ &&
    debugRenderPhaseSideEffectsForStrictMode &&
    (workInProgress.mode & StrictLegacyMode) !== NoMode;

  shouldDoubleInvokeUserFnsInHooksDEV = shouldDoubleRenderDEV;
  let children = __DEV__
    ? callComponentInDEV(Component, props, secondArg)
    : Component(props, secondArg);
  shouldDoubleInvokeUserFnsInHooksDEV = false;

  /**
	 ë Œë” íŒ¨ìŠ¤ ì¤‘ì—ë§Œ ì—…ë°ì´íŠ¸ê°€ ì˜ˆì•½ëœ ê²½ìš° ì‹œë„í•  ë•Œ ë§ˆë‹¤ ì¬ì„¤ì •ë˜ëŠ”
	ê°’ìœ¼ë¡œ didScheduleRenderPhaseUpdate ë‚˜ numberOfReRendersì„ ì´ìš©í•´
	í†µí•©í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì´ ìˆì–´ë³´ì¸ë‹¤. ë¼ëŠ” ê²ƒì„ ë¯¸ë£¨ì–´ë³¼ ë•Œ êµ³ì´ ì‹ ê²½ì“¸ í•„ìš”ëŠ” ì—†ëŠ”
	ì¹œêµ¬ë¡œ ë³´ì¸ë‹¤.
  */
  if (didScheduleRenderPhaseUpdateDuringThisPass) {
    children = renderWithHooksAgain(
      workInProgress,
      Component,
      props,
      secondArg
    );
  }

  if (shouldDoubleRenderDEV) {
    setIsStrictModeForDevtools(true);
    try {
      children = renderWithHooksAgain(
        workInProgress,
        Component,
        props,
        secondArg
      );
    } finally {
      setIsStrictModeForDevtools(false);
    }
  }

  // ëª¨ë“  hook ê³„ì‚° ë¡œì§ë“¤ì„ ìˆ˜í–‰í•œ ì´í›„ ê¸°ì¡´ì— ì‚¬ìš©í•˜ë˜ ê°ì²´ë“¤ì„ ë¹„ìš°ëŠ” ì‘ì—…ì„ ìˆ˜í–‰
  finishRenderingHooks(current, workInProgress, Component);

  return children;
}
```

###### currentRenderingFiber

currentRenderingFiberëŠ” Fiber íƒ€ì…ì˜ ê°ì²´ë¡œ ë³€ê²½ë  fiber ë…¸ë“œ ì •ë³´ë¥¼ ë³„ë„ì˜ ë³€ìˆ˜ì— ì €ì¥í•´ì„œ í™œìš©í•©ë‹ˆë‹¤.

```js
currentlyRenderingFiber = workInProgress;
```

```js
export type Fiber = {
	.
	.
	.
	memoizedState: any; // hookì„ ìœ„í•œ fiber ë…¸ë“œì—ì„œ ì €ì¥ëœ, state ê´€ë ¨ ì •ë³´ ì €ì¥ ê°’
	.
	.
}
```

ìœ„ì—ì„œ ë³´ì—¬ì§€ëŠ” Fiber ê°ì²´ëŠ” í˜„ì¬ Hookì—ì„œ ë¹„êµí•˜ê³  ìˆëŠ” Fiber ë…¸ë“œë¥¼ ì €ì¥í•˜ëŠ” ìœ„ì¹˜ë¡œ,
í˜„ì¬ ì§„í–‰ ì¤‘ì¸ useStateê°™ì€ ìƒíƒœ ê´€ë¦¬ hook ê´€ë ¨ ì •ë³´ë¥¼ ì „ë¶€ ì €ì¥í•˜ëŠ” ê³µê°„ì…ë‹ˆë‹¤.

ì„ì‹œ ê³µê°„ì´ê¸°ì— ë Œë”ë§ì´ ì™„ë£Œë˜ë©´ ë¹„ì›Œì§„ë‹¤.

```js
// ë§¤ê°œë³€ìˆ˜ ê°ì²´ë¥¼ ì§ì ‘ ìˆ˜ì •í•˜ëŠ” ì¼€ì´ìŠ¤
workInProgress.memoizedState = null;
workInProgress.updateQueue = null;
workInProgress.lanes = NoLanes;
```

ì¼ë°˜ì ìœ¼ë¡œ í•¨ìˆ˜ì—ì„œ ë°›ì•„ì˜¨ ë§¤ê°œë³€ìˆ˜ëŠ” ì§ì ‘ ìˆ˜ì •ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤. <br />
í•˜ì§€ë§Œ í•´ë‹¹ í•¨ìˆ˜ì—ì„œëŠ” ì§ì ‘ ìˆ˜ì •í•˜ê³  ìˆëŠ”ë° ì´ ì´ìœ ëŠ” **Value Type and Reference Type**ê³¼ ì—°ê´€ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

<br />

###### ğŸŒŸ Value Type and Reference Type

**Value Type and Reference Type**ì€ ë³€ìˆ˜ í• ë‹¹ ë°©ë²•ê³¼ ê´€ë ¨ì´ ìˆìŠµë‹ˆë‹¤. <br />
ë³€ìˆ˜ ê°’ì´ ë“¤ì–´ê°€ê²Œ ëœë‹¤ë©´, ê·¸ ë³€ìˆ˜ë¥¼ ì €ì¥í•˜ê¸° ìœ„í•´ ë©”ëª¨ë¦¬ ê³µê°„ì´ í• ë‹¹ë˜ê³  ê·¸ ë©”ëª¨ë¦¬ ê³µê°„ì˜ ì£¼ì†Œ ë˜í•œ ë°˜í™˜ë˜ê²Œ ë˜ëŠ” ê²ƒì„ ë§í•©ë‹ˆë‹¤.

1.  Call by Value (Value Type)

Call by ValueëŠ” ì›ì‹œ íƒ€ì…(primitive type)ìœ¼ë¡œ ë©”ëª¨ë¦¬ ê³µê°„ì´ í• ë‹¹ë˜ë”ë¼ë„ ì‹¤ì œë¡œ ë°˜í™˜í•˜ëŠ” ê°’ì€ ê°’ ìì²´ë¥¼ ë°˜í™˜í•˜ê²Œ ë©ë‹ˆë‹¤. <br />
C ê³„ì—´ì˜ ì–¸ì–´(C, C++ ë“±)ì—ì„œëŠ” í•´ë‹¹ ê°’ì˜ ë©”ëª¨ë¦¬ ì£¼ì†Œë¥¼ ê°€ì ¸ì˜¤ëŠ” pointer ë˜í•œ ì‚¬ìš©ì´ ê°€ëŠ¥í•˜ì§€ë§Œ ê¸°ë³¸ì ìœ¼ë¡œëŠ” ê°’ ìì²´ë¥¼ ê°€ì ¸ì˜¤ê²Œ ë©ë‹ˆë‹¤.

2. Call by Reference (Reference Type)

Call by ReferenceëŠ” ì°¸ì¡° íƒ€ì…(reference type)ìœ¼ë¡œ ì‹¤ì œ ë°ì´í„°ê°€ ë³´ê´€ë˜ëŠ” ë©”ëª¨ë¦¬ ì£¼ì†Œì— ëŒ€í•œ ì°¸ì¡° ê°’ì„ ì €ì¥ë©ë‹ˆë‹¤. <br />
ì˜ˆë¥¼ ë“¤ì–´ `{ a: "Test" }` ë¼ëŠ” ê°ì²´ë¥¼ A ë¼ëŠ” ë³€ìˆ˜ì— ì €ì¥í•˜ê²Œ ëœë‹¤ë©´, ë‚¨ëŠ” ë©”ëª¨ë¦¬ ê³µê°„ì— ê°’ì´ í• ë‹¹ë˜ê²Œ ë˜ê³  Aë¼ëŠ” ê°’ì—ëŠ” ë©”ëª¨ë¦¬ ì£¼ì†Œê°€ ë°˜í™˜ë©ë‹ˆë‹¤.

```c++
#include <iostream>

// ì‹¤ì œë¡œ ë©”ëª¨ë¦¬ ì£¼ì†Œë¥¼ í™œìš©í•˜ëŠ” ì–¸ì–´ì¸ C++ ì˜ˆì‹œ ì½”ë“œ
// ìš°ë¦¬ê°€ í˜„ì¬ ì‚¬ìš©í•˜ëŠ” JSì™€ Javaì—ëŠ” í•´ë‹¹ë˜ì§€ ì•Šìœ¼ë‹ˆ ê·¸ëƒ¥ ì´ë ‡êµ¬ë‚˜ ì •ë„ë¡œ ë³´ê¸¸ ê¶Œì¥
int main()
{
    int a = 10;
     // JSì—ì„œëŠ” consoleì™€ ê°™ì€ ê¸°ëŠ¥ì„ ë‹´ë‹¹
     // ì•ì— &ë¥¼ ë¶™ì„ìœ¼ë¡œì¨ ë©”ëª¨ë¦¬ ì£¼ì†Œë¥¼ ê°€ì ¸ì˜¨ë‹¤ê³  ìƒê°í•˜ë©´ í¸í•¨
    std::cout << &a << std::endl; // 0xdfbffffdcc -> 16ì§„ìˆ˜ ë©”ëª¨ë¦¬ ì£¼ì†Œ ë°˜í™˜

    return 0;
}
```

ë¬¼ë¡  ì‹¤ì œë¡œ ìš°ë¦¬ê°€ ê·¸ ë³€ìˆ˜ë¥¼ í™œìš©í•  ë•ŒëŠ” ê°’ ìì²´ê°€ ë°˜í™˜ë˜ê²Œ ë˜ëŠ”ë°, ì‹¤ì œë¡œëŠ” ë©”ëª¨ë¦¬ ì£¼ì†Œê°€ ì €ì¥ë˜ì–´ ìˆì–´ ë³€ìˆ˜ë¥¼ í™œìš©í•  ë•ŒëŠ” ê·¸ ì£¼ì†Œì—ì„œ ê°’ì„ êº¼ë‚´ì™€ì„œ ë°˜í™˜í•˜ê²Œ ë˜ëŠ” êµ¬ì¡°ì…ë‹ˆë‹¤.

<br />

###### ì˜ˆì œ

```js
const a = { a: "test" };
const b = a;
const c = { a: "test" };

1. console.log(a === b); // ?
2. console.log(a === c); // ?

a.a = "b";
3. console.log(a.a); // ?
4. console.log(b.a); // ?
```

<br />
<br />

#### isUpdate

ì‹¤ì œë¡œ ë¦¬ì•¡íŠ¸ ë‚´ì— ìˆëŠ” í•¨ìˆ˜ëŠ” ì•„ë‹™ë‹ˆë‹¤. <br />
ì‹¤ì œ ê·¸ë¦¼ì—ì„œ ê·¸ë¦° í•µì‹¬ ë¡œì§ì€ ì•„ë˜ ë‚´ìš©ìœ¼ë¡œ ì•„ë˜ ì½”ë“œë§Œ ì¸ì§€í•˜ê³  ìˆìœ¼ë©´ ë©ë‹ˆë‹¤.

```js
ReactSharedInternals.H =
  // (current === null || current.memoizedState === null)ì˜ ì¡°ê±´ì€ mount
  current === null || current.memoizedState === null
    ? HooksDispatcherOnMount
    : HooksDispatcherOnUpdate;
```

- `ğŸ“‚ package/react-reconciler/src/ReactFiberHooks.js`

```js
const HooksDispatcherOnMount: Dispatcher = {
  readContext,
  use,
  useCallback: mountCallback,
  useContext: readContext,
  useEffect: mountEffect,
  useImperativeHandle: mountImperativeHandle,
  useLayoutEffect: mountLayoutEffect,
  useInsertionEffect: mountInsertionEffect,
  useMemo: mountMemo,
  useReducer: mountReducer,
  useRef: mountRef,
  useState: mountState, // âœ…
  useDebugValue: mountDebugValue,
  useDeferredValue: mountDeferredValue,
  useTransition: mountTransition,
  useSyncExternalStore: mountSyncExternalStore,
  useId: mountId,
};

const HooksDispatcherOnUpdate: Dispatcher = {
  readContext,
  use,
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useInsertionEffect: updateInsertionEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: updateReducer,
  useRef: updateRef,
  useState: updateState, // âœ…
  useDebugValue: updateDebugValue,
  useDeferredValue: updateDeferredValue,
  useTransition: updateTransition,
  useSyncExternalStore: updateSyncExternalStore,
  useId: updateId,
};
```

<br />
<br />

#### 4ï¸âƒ£ currentHook, workInProgressHook

```js
export type Hook = {
  memoizedState: any, // âœ… ì‹¤ì œ ë Œë”ë§ ì‹œ ë…¸ì¶œì‹œì¼œì¤„ state ê°’
  // ë‚´ë¶€ì—ì„œ ë³€ê²½ëœ ê°’ ìì²´ë¥¼ ë‹¹ì¥ ì €ì¥í•˜ëŠ” state ê°’
  // ì‹¤ì œ setState((prev) => {}); ì‚¬ìš©ì‹œ prevì—ì„œ ì‚¬ìš©í•˜ëŠ” ê°’
  baseState: any, // ì‹¤ì œ ë¦¬ë Œë”ë§ ë˜ê¸° ì „ê¹Œì§€ëŠ” baseStateì— ìš°ì„  ê°’ì„ ì ìš©í•˜ê³  ì´í›„ memoizedStateì— ê°’ì„ ì ìš©
  baseQueue: Update<any, any> | null,
  queue: any,
  next: Hook | null, // ë‹¤ìŒ hook ê°ì²´ ì •ë³´ë¥¼ ì €ì¥í•˜ê¸° ìœ„í•´ Linked List êµ¬ì¡°ë¡œ ì‚¬ìš©
};
```

> ğŸ”– memoizedState <br />
> ì‹¤ì œ ë Œë”ë§ ì‹œ ë…¸ì¶œì‹œì¼œì¤„ state ê°’ <br />
> ë‚´ë¶€ì—ì„œ ë³€ê²½ëœ ê°’ ìì²´ë¥¼ ë‹¹ì¥ ì €ì¥í•˜ëŠ” state ê°’

```js
// memoizedState & baseState

const [state, setState] = useState(0);

const plusOne = () => {
  setState((prev) => prev + 1);
};
```

<br />

> ğŸ”– CurrentHook <br />
> ì´ë¦„ ê·¸ëŒ€ë¡œ ê°ê° ì—…ë°ì´íŠ¸ ì „ì˜ Hook ì •ë³´ <br />
> ì¦‰ ë¦¬ë Œë”ë§ ì´ì „ì˜ Hook ê°ì²´

<br />

> ğŸ”– workInProgressHook <br />
> ë¦¬ë Œë”ë§ì„ ìœ„í•´ ìƒˆë¡œ í• ë‹¹ëœ Fiber ë…¸ë“œ ê¸°ë°˜ìœ¼ë¡œ ë§Œë“¤ì–´ì§€ëŠ” Hook ê°ì²´ <br />
> ì„ì‹œ ê³µê°„ì´ê¸°ì— ë Œë”ë§ì´ ì™„ë£Œë˜ë©´ ë¹„ì›Œì§

<br />
<br />

#### 5ï¸âƒ£ mountState

##### MountState ë¶„ì„

```js
function mountState<S>(
  initialState: (() => S) | S
): [S, Dispatch<BasicStateAction<S>>] {
  const hook = mountStateImpl(initialState);
  const queue = hook.queue;
  const dispatch: Dispatch<BasicStateAction<S>> = (dispatchSetState.bind(
    null,
    currentlyRenderingFiber,
    queue
  ): any);
  queue.dispatch = dispatch;
  return [hook.memoizedState, dispatch];
}
```

##### MountStateImpl ë¶„ì„

ìš°ë¦¬ê°€ ì‚¬ìš©í•  ì •ë³´ë“¤ì„ ëŒ€ë¶€ë¶„ ê°€ì ¸ì˜¤ëŠ” mountStateImplì´ë¼ëŠ” í•¨ìˆ˜ì—ì„œëŠ” hookì´ë¼ëŠ” ê°ì²´ë¥¼ ë°˜í™˜í•´ì£¼ê¸° ìœ„í•œ ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

```js
function mountStateImpl<S>(initialState: (() => S) | S): Hook {
  const hook = mountWorkInProgressHook(); // âœ…
  // useStateì˜ lazyInitializeì— ëŒ€í•œ ë¡œì§ - todo: ì˜ˆì‹œ ì½”ë“œ ë§Œë“¤ì–´ë³´ê¸°
  if (typeof initialState === "function") {
    const initialStateInitializer = initialState;
    initialState = initialStateInitializer(); // âœ…
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(true);
      initialStateInitializer(); // "strict mode"ì—ì„œ ë‘ ë²ˆ í˜¸ì¶œë˜ëŠ” ì´ìœ 
      setIsStrictModeForDevtools(false);
    }
  }
  hook.memoizedState = hook.baseState = initialState; // âœ… mount ì‹œì ì— ë‹¨ í•œ ë²ˆë§Œ í˜¸ì¶œí•´ ì²˜ë¦¬í•  ëª©ì 
  const queue: UpdateQueue<S, BasicStateAction<S>> = {
    pending: null,
    lanes: NoLanes,
    dispatch: null,
    // baseStateReducerë¼ëŠ” í•¨ìˆ˜ë¥¼ ê·¸ëŒ€ë¡œ ì €ì¥í•¨. ì¶”í›„ parameterë¥¼ ë„£ì–´ì„œ í™œìš©
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: (initialState: any),
  };
  hook.queue = queue;
  return hook;
}
```

##### mountWorkInProgressHook

workInProgressHook ì •ë³´ê°€ ìˆëƒ ì—†ëƒì— ë”°ë¼ ì•„ë˜ ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤ :

- ê°’ì´ ì—†ë‹¤ë©´ `currentRenderingFiber`ì™€ `workInProgressHook` ê°ì²´ ì•ˆì— ìƒˆë¡œ ë§Œë“  Hook ê°ì²´ ì •ë³´ë¥¼ ì£¼ì…
- ê·¸ê²ƒì´ ì•„ë‹ˆë¼ë©´ `workInProgressHook`ì™€ `workInProgressHook.next`ì— hook ê°ì²´ë¥¼ ë„£ì–´ì¤Œìœ¼ë¡œì¨ **Linked List**ë¥¼ êµ¬í˜„

ê·¸ ì´í›„ workInProgressHookë¥¼ ë°˜í™˜í•´ì¤ë‹ˆë‹¤.

```js
function mountWorkInProgressHook(): Hook {
  const hook: Hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook === null) {
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook; // This is the first hook in the list
  } else {
    workInProgressHook = workInProgressHook.next = hook; // Append to the end of the list
  }

  return workInProgressHook;
}
```

###### ê²Œìœ¼ë¥¸ ì´ˆê¸°í™”

ì•„ë˜ ë¡œì§ì„ í†µí•´ ê²Œìœ¼ë¥¸ ì´ˆê¸°í™”ë¥¼ ì‹œí‚µë‹ˆë‹¤.

```js
if (typeof initialState === "function") {
  const initialStateInitializer = initialState;
  initialState = initialStateInitializer();
  if (shouldDoubleInvokeUserFnsInHooksDEV) {
    setIsStrictModeForDevtools(true);
    initialStateInitializer();
    setIsStrictModeForDevtools(false);
  }
}
```

<br />
<br />

#### 6ï¸âƒ£ basicStateReducer

setStateë¥¼ ë§Œë“¤ê¸° ìœ„í•´ í•„ìš”í•œ í•¨ìˆ˜ë¡œ, actionì— ë“¤ì–´ê°€ëŠ” ê°’ì´ í•¨ìˆ˜ê°€ ì•„ë‹ˆë¼ë©´ action ìì²´ë¥¼ ë°˜í™˜í•œë‹¤.

```js
function basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {
  // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types
  return typeof action === "function" ? action(state) : action;
}
```

actionì´ í•¨ìˆ˜ê°€ ì•„ë‹Œ ê²½ìš°ëŠ” setState ê¸°ì¤€ìœ¼ë¡œ ë‹¤ìŒê³¼ ê°™ë‹¤.

```js
setState(state + 1); // state + 1 ì´ actionìœ¼ë¡œ ë“¤ì–´ê°€ëŠ” ê°’ -> ìˆ«ìì„
```

actionì´ í•¨ìˆ˜ê°€ ë˜ëŠ” ê²½ìš°ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

```js
setState((prev) => prev + 1); // (prev) => prev + 1ì´ actionìœ¼ë¡œ ë“¤ì–´ê°€ëŠ” ê°’ -> í•¨ìˆ˜ì„
```

<br />
<br />

#### 7ï¸âƒ£ dispatchSetState

```js
function dispatchSetState<S, A>(
  fiber: Fiber,
  queue: UpdateQueue<S, A>,
  action: A
): void {
  if (__DEV__) {
    if (typeof arguments[3] === "function") {
      console.error(
        "State updates from the useState() and useReducer() Hooks don't support the " +
          "second callback argument. To execute a side effect after " +
          "rendering, declare it in the component body with useEffect()."
      );
    }
  }

  const lane = requestUpdateLane(fiber);

  const update: Update<S, A> = {
    lane,
    revertLane: NoLane,
    action,
    hasEagerState: false,
    eagerState: null,
    next: (null: any),
  };

  if (isRenderPhaseUpdate(fiber)) {
    enqueueRenderPhaseUpdate(queue, update);
  } else {
    const alternate = fiber.alternate;
    if (
      fiber.lanes === NoLanes &&
      (alternate === null || alternate.lanes === NoLanes)
    ) {
      const lastRenderedReducer = queue.lastRenderedReducer;
      if (lastRenderedReducer !== null) {
        let prevDispatcher = null;
        if (__DEV__) {
          prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        }
        try {
          // lastRenderedState -> initializeëœ state
          const currentState: S = (queue.lastRenderedState: any);
          const eagerState = lastRenderedReducer(currentState, action);
          update.hasEagerState = true;
          update.eagerState = eagerState;
          if (is(eagerState, currentState)) {
            enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);
            return;
          }
        } catch (error) {
        } finally {
          if (__DEV__) {
            ReactSharedInternals.H = prevDispatcher;
          }
        }
      }
    }

    const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
    if (root !== null) {
      scheduleUpdateOnFiber(root, fiber, lane);
      entangleTransitionUpdate(root, queue, lane);
    }
  }

  markUpdateInDevTools(fiber, lane, action);
}
```

###### í•µì‹¬ ë¡œì§

```js
const currentState: S = (queue.lastRenderedState: any);
const eagerState = lastRenderedReducer(currentState, action);
update.hasEagerState = true;
update.eagerState = eagerState;
if (is(eagerState, currentState)) {
  enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);
  return;
}
```

setStateê°€ ì—…ë°ì´íŠ¸ ë˜ê¸° ìœ„í•´ì„œ ê²€ì¦í•˜ëŠ” ì‘ì—…ì´ í•„ìš”í•œë° í•´ë‹¹ ë¡œì§ì—ì„œ ì´ì „ì˜ stateì™€ ìƒˆë¡­ê²Œ ë°”ë€ŒëŠ” stateë¥¼ ë¹„êµí•˜ëŠ” ë¡œì§ì´ë‹¤.

ê¸°ì¡´ queue ì— ë“¤ì–´ìˆëŠ” ì •ë³´ì¸ lastRerenderedStateì™€ lastRerenderedReducer ë‘ ê°œëŠ” [ì´ì „ì˜ í•¨ìˆ˜](https://www.notion.so/5-mountState-1180d6fc8a7c8076aeaafbedd275a3c6?pvs=21) ì—ì„œ ê°’ì„ í• ë‹¹í•´ì¤¬ë‹¤.

```js
lastRenderedReducer(currentState, action);
```

ìœ„ì˜ lastRerenderedReducerë¥¼ í†µí•´ setState ì‘ì—…ì„ ìˆ˜í–‰í•œë‹¤.

<br />
<br />

#### 8ï¸âƒ£ updateState

```js
function updateState<S>(
  initialState: (() => S) | S
): [S, Dispatch<BasicStateAction<S>>] {
  return updateReducer(basicStateReducer, initialState);
}

function updateReducer<S, I, A>(
  reducer: (S, A) => S,
  initialArg: I,
  init?: (I) => S
): [S, Dispatch<A>] {
  const hook = updateWorkInProgressHook();
  return updateReducerImpl(hook, ((currentHook: any): Hook), reducer);
}
```

UpdateStateëŠ” UpdateReducer í•¨ìˆ˜ë¥¼ ë°˜í™˜í•´ì¤€ë‹¤.

UpdateStateëŠ” initialStateë¥¼ Parameterë¡œ ë„£ì§€ë§Œ ì‚¬ìš©í•˜ì§€ëŠ” ì•Šê³ , [6. basicStateReducer](https://www.notion.so/6-basicStateReducer-1180d6fc8a7c808090b6c78f26b2ca7c?pvs=21) ë§Œ ì‚¬ìš©í•œë‹¤.

###### í•µì‹¬ ì½”ë“œ

```js
function updateWorkInProgressHook(): Hook {
  let nextCurrentHook: null | Hook;
  if (currentHook === null) {
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  let nextWorkInProgressHook: null | Hook;
  if (workInProgressHook === null) {
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    // There's already a work-in-progress. Reuse it.
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;

    currentHook = nextCurrentHook;
  } else {
    // Clone from the current hook.

    if (nextCurrentHook === null) {
      const currentFiber = currentlyRenderingFiber.alternate;
      if (currentFiber === null) {
        // This is the initial render. This branch is reached when the component
        // suspends, resumes, then renders an additional hook.
        // Should never be reached because we should switch to the mount dispatcher first.
        throw new Error(
          "Update hook called on initial render. This is likely a bug in React. Please file an issue."
        );
      } else {
        // This is an update. We should always have a current hook.
        throw new Error("Rendered more hooks than during the previous render.");
      }
    }

    currentHook = nextCurrentHook;

    const newHook: Hook = {
      memoizedState: currentHook.memoizedState,

      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,

      next: null,
    };

    if (workInProgressHook === null) {
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}
```

<br />
<br />
